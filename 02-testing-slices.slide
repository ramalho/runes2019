Slices and table tests
Chapter 2
03 Aug 2020
Tags: golang, tdd, testing, unicode

Luciano Ramalho
Principal Consultant, ThoughtWorks
luciano.ramalho@thoughtworks.com
https://standupdev.com/
@ramalhoorg

* Generating named characters

* Scanning the UCD

Given a `rune` value, `runenames.Name` returns the character name, as given by the `UnicodeData.txt` file.

We'll code a `scan` function to return a slice of `CharName` structs for characters that have a unique name.

To make testing easier, `scan` will take two `rune` arguments setting the start and end of the range of code points to be scanned. The end code point will be excluded. For example, this call will return a slice with `CharName` structs for the letters 'A', 'B', 'C':

    abc := scan('A', 'D')

* Baby step 1: return slice with one `CharName`

.code -numbers 02/runes021/main_test.go /^func Test_scan_A/,/^}/

Note the syntax for literal struct and slice of structs:

    CharName{'A', "LATIN CAPITAL LETTER A"}  // a simple struct value

    []CharName{CharName{'A', "LATIN CAPITAL LETTER A"}}  // a slice with one struct item

    []CharName{{'A', "LATIN CAPITAL LETTER A"}}  // short syntax for slice with struct item(s)

* Baby step 1: satisfy previous test

At first: satisfy what is tested, and only what is tested.

    func scan(start, end rune) []CharName {
        return []CharName{{'A', "LATIN CAPITAL LETTER A"}}
    }

Yes: returning a hard-coded literal is often a good first step.

* Baby step 2: get help for testing slice results

Let's make `scan` return slices with more than one `CharName`.

To test this, we need to compare slices. But `==` and `!=` only work for comparing slices to `nil`. üòø

The most popular way of checking slices and other composite data in tests is using the `testify/assert` package, imported like this:

.code -numbers 02/runes022/main_test.go /^import/,/^\)/

To compile the project, install the `testify` package. Run this command in the shell:

    $ go get github.com/stretchr/testify

* Baby step 2: test slice with three `CharName`

With `testify` installed, we can use the `assert.Equal` function:

.code -numbers 02/runes022/main_test.go /^func Test_scan_ABC/,/^}/

The `testify/assert` functions provide:

- Checks for data structures, partial matches, delays, panics, error values etc.
- Nice error reporting (no need to build messages with `t.Errorf`)

* Output of `assert.Equal` failing

    $ go test
    --- FAIL: Test_scan_ABC (0.00s)
        main_test.go:55:
                Error Trace:	main_test.go:55
                Error:      	Not equal:
                                expected: []main.CharName{main.CharName{Char:65, Name:"LATIN CAPITAL LETTER A"}, main.CharName{Char:66, Name:"LATIN CAPITAL LETTER B"}, main.CharName{Char:66, Name:"LATIN CAPITAL LETTER B"}}
                                actual  : []main.CharName{main.CharName{Char:65, Name:"LATIN CAPITAL LETTER A"}}

                                Diff:
                                --- Expected
                                +++ Actual
                                @@ -1,5 +1,3 @@
                                -([]main.CharName) (len=3) {
                                - (main.CharName) U+0041	A	LATIN CAPITAL LETTER A,
                                - (main.CharName) U+0042	B	LATIN CAPITAL LETTER B,
                                - (main.CharName) U+0042	B	LATIN CAPITAL LETTER B
                                +([]main.CharName) (len=1) {
                                + (main.CharName) U+0041	A	LATIN CAPITAL LETTER A
                                }
                Test:       	Test_scan_ABC
    FAIL
    exit status 1
    FAIL	github.com/standupdev/runes2019/chapter02/runes022	0.027s

* Baby step 2: implement loop in `scan`

.code -numbers 02/runes022/main.go /^func scan/,/^}/

The `append` function takes a slice and an element, and returns a new slice with the element appended at the end.

‚ò† *WARNING*: Slices are efficient but tricky; different slices may share the same _underlying_array_ üôÄ. Careless use of slices can lead to very nasty heisenbugs. üêõüëª

Read:

- [[https://blog.golang.org/go-slices-usage-and-internals][Go Blog ‚Äî Go Slices: usage and internals]]
- [[https://github.com/golang/go/wiki/SliceTricks][Go Wiki ‚Äî SliceTricks]]

* Skipping ranges of characters

* Unassigned characters

Unicode has room for 1,114,111 _code_points_, from U+0000 to U+10FFFF.

Only about 10% of those code points have characters assigned to them as of 2019.

There are ranges with thousands of unassigned characters, but the first gap in Unicode 12 can be found in this part of `UnicodeData.txt`:

    0375;GREEK LOWER NUMERAL SIGN;Sk;0;ON;;;;;N;;;;;
    0376;GREEK CAPITAL LETTER PAMPHYLIAN DIGAMMA;Lu;0;L;;;;;N;;;;0377;
    0377;GREEK SMALL LETTER PAMPHYLIAN DIGAMMA;Ll;0;L;;;;;N;;;0376;;0376
    037A;GREEK YPOGEGRAMMENI;Lm;0;L;<compat> 0020 0345;;;;N;GREEK SPACING IOTA BELOW;;;;
    037B;GREEK SMALL REVERSED LUNATE SIGMA SYMBOL;Ll;0;L;;;;;N;;;03FD;;03FD
    037C;GREEK SMALL DOTTED LUNATE SIGMA SYMBOL;Ll;0;L;;;;;N;;;03FE;;03FE

Can you spot the missing code points? How many are missing in this range?

Given an unassigned `rune` value, `runenames.Name` returns an empty string.

We will use this information to create a new test and change `scan` to skip unassigned characters.

* Baby step 3: test range with unassigned code points

This is a copy of the `Test_scan_ABC` test with a new name and new parameters:

.code -numbers 02/runes023/main_test.go /^func Test_scan_unassigned/,/^}/

* Baby step 3: skip characters with empty names

.code -numbers 02/runes023/main.go /^func scan/,/^}/

* Unnamed characters

Among the assigned characters, more than 70% are CJK (Chinese/Japanese/Korean) ideographs that are not individually named. For example, here is what the `runenames.Name` function says about the traditional Chinese character Ê∞£ (qi), meaning "vital energy":

.play -edit 02/assets/qi.go

* Listing ranges of characters that don't have unique names

.play -edit 02/assets/noname.go

* Detecting generic names

If a character does not have a unique name in `UnicodeData.txt`, then `runenames.Name` returns its generic name inside `<‚Ä¶>`.

For example, the first 32 lines of `UnicodeData.txt` are ASCII control codes:

    0000;<control>;Cc;0;BN;;;;;N;NULL;;;;
    0001;<control>;Cc;0;BN;;;;;N;START OF HEADING;;;;
    0002;<control>;Cc;0;BN;;;;;N;START OF TEXT;;;;
    0003;<control>;Cc;0;BN;;;;;N;END OF TEXT;;;;
    0004;<control>;Cc;0;BN;;;;;N;END OF TRANSMISSION;;;;
    0005;<control>;Cc;0;BN;;;;;N;ENQUIRY;;;;
    0006;<control>;Cc;0;BN;;;;;N;ACKNOWLEDGE;;;;
    0007;<control>;Cc;0;BN;;;;;N;BELL;;;;
    0008;<control>;Cc;0;BN;;;;;N;BACKSPACE;;;;
    0009;<control>;Cc;0;S;;;;;N;CHARACTER TABULATION;;;;
    000A;<control>;Cc;0;B;;;;;N;LINE FEED (LF);;;;
    000B;<control>;Cc;0;S;;;;;N;LINE TABULATION;;;;
    000C;<control>;Cc;0;WS;;;;;N;FORM FEED (FF);;;;
    000D;<control>;Cc;0;B;;;;;N;CARRIAGE RETURN (CR);;;;
    000E;<control>;Cc;0;BN;;;;;N;SHIFT OUT;;;;
    000F;<control>;Cc;0;BN;;;;;N;SHIFT IN;;;;
    0010;<control>;Cc;0;BN;;;;;N;DATA LINK ESCAPE;;;;

* Lab 2.1: skipping unnamed characters

*1.* Create a new test named `Test_scan_unnamed` by copying `Test_scan_unassigned`.

*2.* Change the `start`, `end` values to `\x1E`, `\x22`, corresponding to this range or `UnicodeData.txt`:

    001E;<control>;Cc;0;B;;;;;N;INFORMATION SEPARATOR TWO;;;;
    001F;<control>;Cc;0;S;;;;;N;INFORMATION SEPARATOR ONE;;;;
    0020;SPACE;Zs;0;WS;;;;;N;;;;;
    0021;EXCLAMATION MARK;Po;0;ON;;;;;N;;;;;

*3.* Rewrite the expected value for `[]CharName` accordingly.

*4.* Run the tests to see this new one fail. You should see a diff generated by `testify`.

*5.* Add code to the `scan` function to make all tests pass.

*üñê* *SPOILER* *ALERT*: The next slide has tips to help you solve this lab problem. Try to solve it before reading the tips. If needed, read one tip, and try some more. Don't feel bad if you need all the tips, but do try to work without them as much as possible.

* Lab 2.1: tips

- In Go, the boolean *or* operator is the same as Java, JavaScript, etc.

- The best way to check the prefix of a string is to use [[https://golang.org/pkg/strings/#HasPrefix][strings.HasPrefix]]. You'll need to import the `strings` package.

* Table tests

Multiple tests can be combined building a table of inputs/outputs and subtests using the `t.Run` method of `testing.T`.

For details:

- [[https://github.com/golang/go/wiki/TableDrivenTests][Go Wiki ‚Äî TableDrivenTests]]

See example on the next slide.

* Example: table test with 6 subtests

.code -numbers 02/assets/gcd/gcd_test.go /^func TestGcd_table/,/^}/

* Lab 2.2: Refactoring with subtests

We have coded four tests for the `scan` function:

    Test_scan_A
    Test_scan_ABC
    Test_scan_unassigned
    Test_scan_unnamed

Your task: combine them into one `Test_scan` function using a table of inputs/outputs.

*Tips*

- Copy the layout of the `TestGcd` example from the previous slide.

- Refactor one test at a time.

- Make the `Test_scan` pass using just the inputs/outputs of `Test_scan_A`, then delete that test.


*üñê* *SPOILER* *ALERT*: The next slide shows a partial solution.

* Lab 2.2: Partial solution

This partial solution shows the `Test_scan` function with only one item in the inputs/ouputs table: the data from the `Test_scan_A` test.

.code 02/assets/tabletest.go


* End of chapter 2 üéâüéâ
